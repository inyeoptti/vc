<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BBW ìŠ¤íŒŒì´í¬ ëª¨ë‹ˆí„° - Binance Futures</title>
    <style>
      :root {
        --bg: #0b0e11;
        --text: #e5e7eb;
        --muted: #94a3b8;
        --accent: #10b981;
        --up: #22c55e;
        --down: #ef4444;
        --warn: #f59e0b;
        --glass-bg: rgba(255, 255, 255, 0.06);
        --glass-border: rgba(255, 255, 255, 0.14);
        --glass-soft-border: rgba(255, 255, 255, 0.08);
        --blur: 14px;
        --radius: 14px;
        --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      }
      html {
        background: var(--bg);
      }
      body {
        margin: 0;
        padding: 0;
        color: var(--text);
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Ubuntu, Cantarell, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        background:
          radial-gradient(1200px 800px at 10% -10%, rgba(16, 185, 129, 0.14), transparent 60%),
          radial-gradient(1000px 700px at 90% 10%, rgba(14, 165, 233, 0.12), transparent 60%),
          radial-gradient(900px 600px at 50% 120%, rgba(147, 51, 234, 0.12), transparent 60%),
          linear-gradient(180deg, #0b0e11, #0b0e11 35%, #0e1217);
        background-repeat: no-repeat;
        background-position: center top, right -10% top, center 120%, center top;
        min-height: 100vh;
      }
      ::selection {
        background: rgba(16, 185, 129, 0.35);
        color: #fff;
      }
      header {
        position: sticky;
        top: 0;
        z-index: 10;
        width: 100%;
        padding: 12px 16px;
        background: var(--glass-bg);
        -webkit-backdrop-filter: blur(var(--blur));
        backdrop-filter: blur(var(--blur));
        border-bottom: 1px solid var(--glass-border);
      }
      .title {
        font-weight: 800;
        font-size: 18px;
        letter-spacing: 0.2px;
        background: linear-gradient(90deg, #a5b4fc, #22d3ee, #10b981);
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        background-size: 200% 200%;
        animation: sheen 8s linear infinite;
      }
      @keyframes sheen {
        0% { background-position: 0% 50%; }
        100% { background-position: 100% 50%; }
      }
      .controls {
        display: flex;
        gap: 10px;
        align-items: center;
        margin-top: 8px;
        flex-wrap: wrap;
      }
      .chip {
        background: transparent;
        color: var(--muted);
        padding: 0;
        border-radius: 0;
        font-size: 12px;
        border: 0;
        -webkit-backdrop-filter: none;
        backdrop-filter: none;
        box-shadow: none;
      }
      .chip.button { cursor: pointer; color: var(--text); user-select: none; }
      .chip.button:hover { color: #ffffff; }
      #statusText { color: var(--text); font-weight: 600; }
      .controls .chip:not(:last-child)::after { content: 'Â·'; margin: 0 8px; color: var(--muted); opacity: 0.6; }
      main {
        padding: 16px 16px 84px;
        max-width: 1200px;
        margin: 0 auto;
      }
      .glass-card {
        background: var(--glass-bg);
        border: 1px solid var(--glass-border);
        border-radius: var(--radius);
        -webkit-backdrop-filter: blur(var(--blur));
        backdrop-filter: blur(var(--blur));
        box-shadow: var(--shadow);
      }
      .table-wrap {
        overflow: hidden;
      }
      table {
        width: 100%;
        border-collapse: collapse;
      }
      thead th {
        text-align: left;
        padding: 10px 12px;
        font-size: 12px;
        color: var(--muted);
        border-bottom: 1px solid var(--glass-soft-border);
        /* position: sticky; */
        /* top: var(--sticky-offset, 72px); */
        background: rgba(15, 18, 23, 0.6);
        -webkit-backdrop-filter: blur(var(--blur));
        backdrop-filter: blur(var(--blur));
        /* z-index: 7; */
      }
      tbody td {
        padding: 10px 12px;
        border-bottom: 1px solid var(--glass-soft-border);
        vertical-align: middle;
        font-size: 13px;
        transition: background-color 0.25s ease;
      }
      tbody tr:hover td {
        background: rgba(255, 255, 255, 0.035);
      }
      .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
      .symbol { font-weight: 700; letter-spacing: 0.3px; }
      .muted { color: var(--muted); }
      .up { color: var(--up); text-shadow: 0 0 10px rgba(34, 197, 94, 0.2); }
      .down { color: var(--down); text-shadow: 0 0 10px rgba(239, 68, 68, 0.15); }
      .warn { color: var(--warn); }
      .status {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      .status .label {
        color: var(--muted);
        font-size: 12px;
      }
      .small { font-size: 12px; }
      .right { text-align: right; }
      .center { text-align: center; }
      canvas.preview {
        display: block;
        background: rgba(15, 19, 24, 0.7);
        border-radius: 8px;
        border: 1px solid var(--glass-soft-border);
        box-shadow: inset 0 1px 0 rgba(255,255,255,0.04), 0 0 0 3px rgba(16, 185, 129, 0.04);
      }
      .sticky-footer {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: var(--glass-bg);
        border-top: 1px solid var(--glass-border);
        padding: 10px 16px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        -webkit-backdrop-filter: blur(var(--blur));
        backdrop-filter: blur(var(--blur));
        box-shadow: 0 -8px 20px rgba(0,0,0,0.25);
      }
      .sticky-footer .status .label { display: none; }
      .hidden { display: none; }
      /* Scrollbar (WebKit) */
      *::-webkit-scrollbar { width: 10px; height: 10px; }
      *::-webkit-scrollbar-thumb { background: rgba(148,163,184,0.3); border-radius: 999px; border: 2px solid transparent; background-clip: padding-box; }
      *::-webkit-scrollbar-track { background: transparent; }
    </style>
  </head>
  <body>
    <header>
      <div class="title">BBW ìŠ¤íŒŒì´í¬ ëª¨ë‹ˆí„°</div>
      <div class="controls">
        <span id="statusText" class="chip">ì´ˆê¸°í™” ì¤‘â€¦</span>
        <span id="symbolsCount" class="chip">ì‹¬ë³¼: -</span>
        <span id="loadedCount" class="chip">ì´ˆê¸° ìº”ë“¤: 0</span>
        <span id="wsState" class="chip">WS: -</span>
        <span class="chip">ì¡°ê±´: prev BBW â‰¤ 0.02 && í˜„ ë´‰ +1% ìµœì´ˆ ëŒíŒŒ</span>
        <span id="soundToggle" class="chip button" title="ì•Œë¦¼ ì†Œë¦¬ í† ê¸€">ğŸ”ˆ ì†Œë¦¬ ë”</span>
      </div>
    </header>
    <main>
      <div class="glass-card table-wrap">
        <table>
          <thead>
            <tr>
              <th>í‹°ì»¤</th>
              <th>í”„ë¦¬ë·°</th>
              <th class="right">ê±°ë˜ëŸ‰(USDT)</th>
              <th class="right">ë³¼ë¥¨ Z</th>
              <th class="right">BBW ì¦ê°€</th>
              <th class="right">ë¶„ë´‰ ì‹œì‘</th>
            </tr>
          </thead>
          <tbody id="resultsBody"></tbody>
        </table>
      </div>
    </main>
    <div class="sticky-footer">
      <div class="status">
        <span class="label">ì§„í–‰ìƒíƒœ:</span>
        <span id="footerStatus">-</span>
      </div>
      <div class="status">
        <span class="label">ìµœê·¼ íƒì§€:</span>
        <span id="recentDetections" class="muted">ì—†ìŒ</span>
      </div>
    </div>

    <script type="module">
      // ì•Œë¦¼ ì†Œë¦¬ (Web Audio) ì„¤ì •
      let audioCtx = null;
      let soundEnabled = false;
      function ensureAudio() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      function playDing() {
        if (!soundEnabled) return;
        ensureAudio();
        const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sine';
        // ì§§ì€ ë”©: ë‘ í†¤ ê¸€ë¦¬ì‚°ë„
        osc.frequency.setValueAtTime(880, now);
        osc.frequency.exponentialRampToValueAtTime(1320, now + 0.12);
        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(0.15, now + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.22);
        osc.connect(gain).connect(audioCtx.destination);
        osc.start(now);
        osc.stop(now + 0.25);
      }
      const API_BASE = 'https://fapi.binance.com';
      const WS_BASE = 'wss://fstream.binance.com/stream';
      const INTERVAL = '1m';
      const KLINE_LIMIT = 21; // ìµœì†Œ 21ê°œ ìœ ì§€
      const BB_LENGTH = 20;
      const BB_K = 2;
      const BBW_THRESHOLD = 0.02; // 2%
      const SPIKE_PCT = 0.01; // +1%
      const MAX_ROWS = 400;

      const dom = {
        statusText: document.getElementById('statusText'),
        symbolsCount: document.getElementById('symbolsCount'),
        loadedCount: document.getElementById('loadedCount'),
        wsState: document.getElementById('wsState'),
        resultsBody: document.getElementById('resultsBody'),
        footerStatus: document.getElementById('footerStatus'),
        recentDetections: document.getElementById('recentDetections'),
        soundToggle: document.getElementById('soundToggle'),
      };

      function setStatus(text) {
        dom.statusText.textContent = text;
        dom.footerStatus.textContent = text;
      }

      // ì†Œë¦¬ í† ê¸€ ì´ë²¤íŠ¸ (ì²« í´ë¦­ ì‹œ ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ í™œì„±í™”)
      if (dom.soundToggle) {
        dom.soundToggle.addEventListener('click', async () => {
          try {
            ensureAudio();
            if (audioCtx.state === 'suspended') await audioCtx.resume();
          } catch {}
          soundEnabled = !soundEnabled;
          dom.soundToggle.textContent = soundEnabled ? 'ğŸ”Š ì†Œë¦¬ ì¼¬' : 'ğŸ”ˆ ì†Œë¦¬ ë”';
          if (soundEnabled) playDing();
        });
      }

      function fmtNumber(n, digits = 2) {
        if (!isFinite(n)) return '-';
        return n.toLocaleString(undefined, { maximumFractionDigits: digits });
      }

      function fmtTimeMinute(ts) {
        const d = new Date(ts);
        const h = String(d.getHours()).padStart(2, '0');
        const m = String(d.getMinutes()).padStart(2, '0');
        return `${h}:${m}`;
      }

      function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

      // ìˆ˜í•™ ìœ í‹¸
      function mean(values) {
        if (values.length === 0) return 0;
        let sum = 0;
        for (const v of values) sum += v;
        return sum / values.length;
      }
      function stddev(values) {
        if (values.length < 2) return 0;
        const m = mean(values);
        let acc = 0;
        for (const v of values) acc += (v - m) * (v - m);
        return Math.sqrt(acc / values.length);
      }
      function computeBBW(closes, k = BB_K) {
        if (closes.length < BB_LENGTH) return 0;
        const last20 = closes.slice(closes.length - BB_LENGTH);
        const m = mean(last20);
        const s = stddev(last20);
        if (m === 0) return 0;
        const upper = m + k * s;
        const lower = m - k * s;
        return (upper - lower) / m;
      }
      function computeZScore(samples, current) {
        if (samples.length < 2) return 0;
        const m = mean(samples);
        const s = stddev(samples);
        if (s === 0) return 0;
        return (current - m) / s;
      }

      // ìƒíƒœ ì €ì¥ì†Œ
      const symbols = [];
      const candlesBySymbol = new Map(); // symbol -> Array<Candle>
      const reportedByCandle = new Map(); // key `${symbol}:${openTime}` -> true
      let ws;

      /** @typedef {{ openTime:number, open:number, high:number, low:number, close:number, volume:number, quoteVolume:number, closeTime:number, isClosed:boolean }} Candle */

      async function fetchExchangeInfo() {
        const url = `${API_BASE}/fapi/v1/exchangeInfo`;
        const res = await fetch(url);
        if (!res.ok) throw new Error('exchangeInfo ì‹¤íŒ¨');
        const data = await res.json();
        const usdtPerp = data.symbols.filter(s => (
          s.quoteAsset === 'USDT' && s.contractType === 'PERPETUAL' && s.status === 'TRADING'
        ));
        const list = usdtPerp.map(s => s.symbol);
        return list;
      }

      async function fetchKlines(symbol) {
        const url = `${API_BASE}/fapi/v1/klines?symbol=${symbol}&interval=${INTERVAL}&limit=${KLINE_LIMIT}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error(`klines ì‹¤íŒ¨: ${symbol}`);
        const arr = await res.json();
        /** @type {Candle[]} */
        const candles = arr.map(row => ({
          openTime: row[0],
          open: Number(row[1]),
          high: Number(row[2]),
          low: Number(row[3]),
          close: Number(row[4]),
          volume: Number(row[5]),
          closeTime: row[6],
          quoteVolume: Number(row[7]),
          isClosed: true,
        }));
        return candles;
      }

      async function loadInitialKlines(allSymbols) {
        const concurrency = 50;
        let loaded = 0;
        async function worker(queue) {
          while (queue.length) {
            const sym = queue.shift();
            try {
              const candles = await fetchKlines(sym);
              candlesBySymbol.set(sym, candles);
            } catch (e) {
              console.error('ì´ˆê¸° klines ì‹¤íŒ¨', sym, e);
            } finally {
              loaded++;
              dom.loadedCount.textContent = `ì´ˆê¸° ìº”ë“¤: ${loaded}`;
            }
            // ê°„ë‹¨ ë°±ì˜¤í”„
            // await sleep(80);
          }
        }
        const queue = allSymbols.slice();
        const workers = Array.from({ length: concurrency }, () => worker(queue));
        await Promise.all(workers);
      }

      function openWebSocketAndSubscribe(allSymbols) {
        if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
          try { ws.close(); } catch {}
        }
        ws = new WebSocket(WS_BASE);
        ws.addEventListener('open', () => {
          dom.wsState.textContent = 'WS: ì—°ê²°ë¨';
          setStatus('ì›¹ì†Œì¼“ êµ¬ë… ì¤‘â€¦');
          // êµ¬ë… íŒŒë¼ë¯¸í„°ë¥¼ ë¶„í•  ì „ì†¡í•˜ì—¬ ì„œë²„/ë¸Œë¼ìš°ì € ì œí•œ íšŒí”¼
          const params = allSymbols.map(s => `${s.toLowerCase()}@kline_${INTERVAL}`);
          const chunkSize = 200;
          for (let i = 0; i < params.length; i += chunkSize) {
            const chunk = params.slice(i, i + chunkSize);
            const msg = { method: 'SUBSCRIBE', params: chunk, id: i / chunkSize + 1 };
            ws.send(JSON.stringify(msg));
          }
          // êµ¬ë… ë©”ì‹œì§€ ì „ì†¡ ì™„ë£Œ â†’ ëª¨ë‹ˆí„°ë§ ì‹œì‘ ìƒíƒœë¡œ ì „í™˜
          setStatus('ëª¨ë‹ˆí„°ë§ ì‹œì‘');
        });
        ws.addEventListener('close', () => {
          dom.wsState.textContent = 'WS: í•´ì œë¨ (ì¬ì‹œë„)';
          setStatus('ì—°ê²° ì¢…ë£Œë¨. 2ì´ˆ í›„ ì¬ì—°ê²°â€¦');
          setTimeout(() => openWebSocketAndSubscribe(allSymbols), 2000);
        });
        ws.addEventListener('error', (e) => {
          dom.wsState.textContent = 'WS: ì˜¤ë¥˜';
          console.error('WS ì˜¤ë¥˜', e);
        });
        ws.addEventListener('message', (ev) => {
          try {
            const data = JSON.parse(ev.data);
            // ë‹¨ì¼ ë˜ëŠ” ìŠ¤íŠ¸ë¦¼ ë˜í•‘
            const payload = data.data?.k ? data.data : (data.k ? data : null);
            if (!payload) return;
            const k = payload.k;
            if (k.i !== INTERVAL) return;
            const symbol = k.s;
            const candles = candlesBySymbol.get(symbol);
            if (!candles) return;

            const openTime = k.t; // í˜„ì¬ ë´‰ ì‹œì‘
            const current = {
              openTime: k.t,
              open: Number(k.o),
              high: Number(k.h),
              low: Number(k.l),
              close: Number(k.c),
              volume: Number(k.v),
              quoteVolume: Number(k.q),
              closeTime: k.T,
              isClosed: k.x,
            };

            const last = candles[candles.length - 1];
            if (!last || openTime > last.openTime) {
              // ìƒˆ ë´‰ ì‹œì‘ â†’ ë¡¤ë§ ì—…ë°ì´íŠ¸
              candles.push(current);
              while (candles.length > KLINE_LIMIT) candles.shift();
            } else if (openTime === last.openTime) {
              // í˜„ì¬ ì§„í–‰ì¤‘ì¸ ë´‰ ê°±ì‹ 
              candles[candles.length - 1] = current;
            } else {
              // ì˜¤ë˜ëœ ì´ë²¤íŠ¸ ë¬´ì‹œ
              return;
            }

            onKlineUpdate(symbol, candles);
          } catch (e) {
            console.error('WS ë©”ì‹œì§€ ì²˜ë¦¬ ì‹¤íŒ¨', e);
          }
        });
      }

      function onKlineUpdate(symbol, candles) {
        if (candles.length < KLINE_LIMIT) return;
        const prev = candles[candles.length - 2];
        const curr = candles[candles.length - 1];
        if (!prev || !curr) return;

        const key = `${symbol}:${curr.openTime}`;
        // ì´ì „ ë´‰ì˜ BBW ê³„ì‚° (ë§ˆì§€ë§‰ 20ê°œì˜ ì¢…ê°€: ì• 1ê°œ ì œì™¸)
        const closesPrev = candles.slice(0, candles.length - 1).map(c => c.close);
        const prevBBW = computeBBW(closesPrev);
        if (prevBBW <= 0) return;

        // ì¡°ê±´ 4: ì´ì „ ë´‰ BBW <= 0.02
        const prevBBWPass = prevBBW <= BBW_THRESHOLD;
        if (!prevBBWPass) return;

        // í˜„ì¬ ë´‰ì˜ +1% ìŠ¤íŒŒì´í¬ ìµœì´ˆ ëŒíŒŒ ì—¬ë¶€
        const spike = (curr.high - curr.open) / curr.open >= SPIKE_PCT;
        if (!spike) return;
        if (reportedByCandle.get(key)) return; // ìµœì´ˆ 1íšŒë§Œ

        // í˜„ì¬ ì‹œì ì˜ BBW ì¦ê°€ì¹˜ (í˜„ì¬ ì¢…ê°€ í¬í•¨í•˜ì—¬ ì¸¡ì •)
        const closesWithCurr = candles.map(c => c.close);
        const currBBW = computeBBW(closesWithCurr);
        const bbwIncrease = currBBW - prevBBW;

        // ë³¼ë¥¨ Z-ìŠ¤ì½”ì–´ (ê³¼ê±° 20ê°œ quoteVolume ê¸°ì¤€)
        const prevQuoteVolumes = candles.slice(0, candles.length - 1).slice(-BB_LENGTH).map(c => c.quoteVolume);
        const volZ = computeZScore(prevQuoteVolumes, curr.quoteVolume);

        renderDetectionRow({
          symbol,
          candles: candles.slice(-BB_LENGTH),
          volumeUSDT: curr.quoteVolume,
          volumeZ: volZ,
          bbwIncrease,
          minute: curr.openTime,
        });
        // ì•Œë¦¼ ì†Œë¦¬ ì¡°ê±´: ë³¼ë¥¨ >= 100,000 && Z >= 2
        if (curr.quoteVolume >= 100000 && volZ >= 2) {
          playDing();
        }
        reportedByCandle.set(key, true);
      }

      function renderDetectionRow({ symbol, candles, volumeUSDT, volumeZ, bbwIncrease, minute }) {
        const tr = document.createElement('tr');

        const tdSymbol = document.createElement('td');
        tdSymbol.innerHTML = `<span class="symbol">${symbol}</span>`;

        const tdPreview = document.createElement('td');
        const canvas = document.createElement('canvas');
        canvas.width = 140; canvas.height = 40; canvas.className = 'preview';
        tdPreview.appendChild(canvas);

        const tdVol = document.createElement('td');
        tdVol.className = 'right mono';
        tdVol.textContent = fmtNumber(volumeUSDT, 0);

        const tdZ = document.createElement('td');
        tdZ.className = 'right mono';
        tdZ.textContent = volumeZ.toFixed(2);
        if (volumeZ >= 2) tdZ.classList.add('up');
        else if (volumeZ <= -2) tdZ.classList.add('down');

        const tdBBW = document.createElement('td');
        tdBBW.className = 'right mono';
        const sign = bbwIncrease >= 0 ? '+' : '';
        tdBBW.textContent = `${sign}${(bbwIncrease * 100).toFixed(2)}%`;
        if (bbwIncrease > 0) tdBBW.classList.add('warn');

        const tdTime = document.createElement('td');
        tdTime.className = 'right mono muted';
        tdTime.textContent = fmtTimeMinute(minute);

        tr.appendChild(tdSymbol);
        tr.appendChild(tdPreview);
        tr.appendChild(tdVol);
        tr.appendChild(tdZ);
        tr.appendChild(tdBBW);
        tr.appendChild(tdTime);

        const tbody = dom.resultsBody;
        tbody.insertBefore(tr, tbody.firstChild);
        while (tbody.children.length > MAX_ROWS) tbody.removeChild(tbody.lastChild);

        drawMiniCandles(canvas, candles);

        // ìµœê·¼ íƒì§€ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
        dom.recentDetections.textContent = `${symbol} ${fmtTimeMinute(minute)} (Z ${volumeZ.toFixed(2)})`;
      }

      function drawMiniCandles(canvas, candles) {
        if (!canvas || candles.length === 0) return;
        const ctx = canvas.getContext('2d');
        const w = canvas.width, h = canvas.height;
        ctx.clearRect(0, 0, w, h);

        const highs = candles.map(c => c.high);
        const lows = candles.map(c => c.low);
        const maxH = Math.max(...highs);
        const minL = Math.min(...lows);
        const range = Math.max(1e-9, maxH - minL);

        const n = candles.length;
        const gap = Math.max(1, Math.floor(w / (n + 1)));
        const body = Math.max(1, Math.floor(gap * 0.5));

        for (let i = 0; i < n; i++) {
          const c = candles[i];
          const x = Math.floor((i + 1) * gap);
          const yHigh = Math.floor(h - (c.high - minL) / range * h);
          const yLow = Math.floor(h - (c.low - minL) / range * h);
          const yOpen = Math.floor(h - (c.open - minL) / range * h);
          const yClose = Math.floor(h - (c.close - minL) / range * h);

          // ê¼¬ë¦¬
          ctx.strokeStyle = '#64748b';
          ctx.beginPath();
          ctx.moveTo(x, yHigh);
          ctx.lineTo(x, yLow);
          ctx.stroke();

          // ëª¸í†µ
          const isUp = c.close >= c.open;
          ctx.fillStyle = isUp ? '#22c55e' : '#ef4444';
          const yTop = Math.min(yOpen, yClose);
          const height = Math.max(1, Math.abs(yClose - yOpen));
          ctx.fillRect(x - Math.floor(body / 2), yTop, body, height);
        }
      }

      async function main() {
        try {
          setStatus('ì‹¬ë³¼ ë¡œë”©â€¦');
          const list = await fetchExchangeInfo();
          symbols.push(...list);
          dom.symbolsCount.textContent = `ì‹¬ë³¼: ${symbols.length}`;
          setStatus('ì´ˆê¸° ìº”ë“¤ ë¡œë”©â€¦');
          await loadInitialKlines(symbols);
          setStatus('ì›¹ì†Œì¼“ ì—°ê²°â€¦');
          openWebSocketAndSubscribe(symbols);
          setStatus('ëª¨ë‹ˆí„°ë§ ì‹œì‘');
        } catch (e) {
          console.error(e);
          setStatus('ì˜¤ë¥˜ ë°œìƒ. ì½˜ì†”ì„ í™•ì¸í•˜ì„¸ìš”.');
        }
      }

      main();
    </script>
  </body>
</html>


