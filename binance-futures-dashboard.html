<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼ ëŒ€ì‹œë³´ë“œ</title>
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0b0e11;
            color: #ffffff;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .title {
            font-size: 24px;
            font-weight: 700;
            color: #f0b90b;
        }

        .symbol-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .symbol-selector label {
            font-weight: 500;
        }

        select {
            background: #1e2329;
            border: 1px solid #474d57;
            color: #ffffff;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            min-width: 150px;
        }

        select:focus {
            outline: none;
            border-color: #f0b90b;
        }

        .status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff6b6b;
        }

        .status-dot.connected {
            background: #51cf66;
        }

        .charts-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .chart-section {
            background: #1e2329;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #2b3139;
        }

        .chart-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #ffffff;
        }

        .price-chart {
            height: 400px;
            width: 100%;
        }

        .volume-chart {
            height: 200px;
            width: 100%;
        }

        .ratio-chart {
            height: 200px;
            width: 100%;
        }
        
        .liquidation-chart {
            height: 150px;
            width: 100%;
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 200px;
            font-size: 16px;
            color: #8c8c8c;
        }

        .spinner {
            border: 3px solid #2b3139;
            border-top: 3px solid #f0b90b;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-item {
            background: #2b3139;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
        }

        .stat-label {
            font-size: 12px;
            color: #8c8c8c;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 18px;
            font-weight: 600;
            color: #ffffff;
        }

        .stat-value.positive {
            color: #02c076;
        }

        .stat-value.negative {
            color: #f84960;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .title {
                font-size: 20px;
            }
            
            .price-chart {
                height: 300px;
            }
            
            .volume-chart {
                height: 150px;
            }
            
            .ratio-chart {
                height: 150px;
            }
            
            .liquidation-chart {
                height: 120px;
            }
            
            .stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼ ëŒ€ì‹œë³´ë“œ</h1>
            <div class="symbol-selector">
                <label for="symbolSelect">ì‹¬ë³¼:</label>
                <select id="symbolSelect" disabled>
                    <option>ë¡œë”© ì¤‘...</option>
                </select>
            </div>
            <div class="status">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">ì—°ê²° ì¤‘...</span>
            </div>
        </div>

        <div class="stats" id="stats" style="display: none;">
            <div class="stat-item">
                <div class="stat-label">í˜„ì¬ ê°€ê²©</div>
                <div class="stat-value" id="currentPrice">-</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">1ë¶„ë´‰ ë³€ë™ë¥ </div>
                <div class="stat-value" id="priceChange">-</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">í˜„ì¬ í…Œì´ì»¤ ë¹„ìœ¨</div>
                <div class="stat-value" id="currentRatio">-</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">ê±°ë˜ëŸ‰ (USDT)</div>
                <div class="stat-value" id="volume">-</div>
            </div>
        </div>

        <div class="charts-container">
            <div class="chart-section">
                <div class="chart-title">ì‹¤ì‹œê°„ ê°€ê²© ì°¨íŠ¸ (1ë¶„ ìº”ë“¤)</div>
                <div id="priceChart" class="price-chart">
                    <div class="loading">
                        <div class="spinner"></div>
                        ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...
                    </div>
                </div>
            </div>

            <div class="chart-section">
                <div class="chart-title">ê±°ë˜ëŸ‰ (ğŸŸ¢ë§¤ìˆ˜ vs ğŸ”´ë§¤ë„)</div>
                <div id="volumeChart" class="volume-chart">
                    <div class="loading">
                        <div class="spinner"></div>
                        ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...
                    </div>
                </div>
            </div>

            <div class="chart-section">
                <div class="chart-title">í…Œì´ì»¤ ë§¤ìˆ˜ ë¹„ìœ¨</div>
                <div id="ratioChart" class="ratio-chart">
                    <div class="loading">
                        <div class="spinner"></div>
                        ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...
                    </div>
                </div>
            </div>
            
            <div class="chart-section">
                <div class="chart-title">ê°•ì œì²­ì‚° (ğŸ”´LONG vs ğŸŸ¢SHORT)</div>
                <div id="liquidationChart" class="liquidation-chart">
                    <div class="loading">
                        <div class="spinner"></div>
                        ê°•ì œì²­ì‚° ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class BinanceFuturesDashboard {
            constructor() {
                this.currentSymbol = null;
                this.priceWs = null;
                this.tradeWs = null;
                this.liquidationWs = null;
                this.priceChart = null;
                this.volumeChart = null;
                this.ratioChart = null;
                this.liquidationChart = null;
                this.candlestickSeries = null;
                this.takerVolumeSeries = null;
                this.makerVolumeSeries = null;
                this.ratioSeries = null;
                this.longLiquidationSeries = null;
                this.shortLiquidationSeries = null;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.reconnectDelay = 1000;
                this.reconnectTimeouts = new Set(); // ì¬ì—°ê²° íƒ€ì´ë¨¸ ê´€ë¦¬
                this.isConnecting = false; // ì—°ê²° ì¤‘ ìƒíƒœ í”Œë˜ê·¸
                
                // í…Œì´ì»¤ ë¹„ìœ¨ ê³„ì‚°ì„ ìœ„í•œ ë°ì´í„°
                this.currentMinuteData = {
                    timestamp: null,
                    takerBuyQuoteVolume: 0,
                    totalQuoteVolume: 0
                };
                
                // í…Œì´ì»¤ ë¹„ìœ¨ ìº”ë“¤ ë°ì´í„° ì €ì¥
                this.currentRatioCandle = {
                    timestamp: null,
                    open: null,
                    high: null,
                    low: null,
                    close: null
                };
                
                // ê±°ë˜ëŸ‰ ëˆ„ì‚° ë°ì´í„°
                this.currentVolumeData = {
                    timestamp: null,
                    takerVolume: 0,    // í…Œì´ì»¤(ë§¤ìˆ˜ì) ê±°ë˜ëŸ‰
                    makerVolume: 0     // ë§ˆì¼“ë©”ì´ì»¤(ë§¤ë„ì) ê±°ë˜ëŸ‰
                };
                
                // ê°•ì œì²­ì‚° ëˆ„ì‚° ë°ì´í„°
                this.currentLiquidationData = {
                    timestamp: null,
                    longLiquidation: 0,    // LONG í¬ì§€ì…˜ ê°•ì œì²­ì‚°
                    shortLiquidation: 0    // SHORT í¬ì§€ì…˜ ê°•ì œì²­ì‚°
                };
                
                this.init();
            }

            async init() {
                await this.loadSymbols();
                this.setupEventListeners();
                this.initializeCharts();
            }

            async loadSymbols() {
                try {
                    const response = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo');
                    const data = await response.json();
                    
                    const symbolSelect = document.getElementById('symbolSelect');
                    symbolSelect.innerHTML = '<option value="">ì‹¬ë³¼ì„ ì„ íƒí•˜ì„¸ìš”</option>';
                    
                    // USDT ë§ˆì§„ ì„ ë¬¼ë§Œ í•„í„°ë§
                    const usdtSymbols = data.symbols
                        .filter(symbol => symbol.status === 'TRADING' && symbol.quoteAsset === 'USDT')
                        .sort((a, b) => a.symbol.localeCompare(b.symbol));
                    
                    usdtSymbols.forEach(symbol => {
                        const option = document.createElement('option');
                        option.value = symbol.symbol;
                        option.textContent = symbol.symbol;
                        symbolSelect.appendChild(option);
                    });
                    
                    symbolSelect.disabled = false;
                    
                    // ê¸°ë³¸ì ìœ¼ë¡œ BTCUSDT ì„ íƒ
                    if (usdtSymbols.find(s => s.symbol === 'BTCUSDT')) {
                        symbolSelect.value = 'BTCUSDT';
                        this.onSymbolChange('BTCUSDT');
                    }
                    
                } catch (error) {
                    console.error('ì‹¬ë³¼ ë¡œë”© ì‹¤íŒ¨:', error);
                    this.updateStatus('ì‹¬ë³¼ ë¡œë”© ì‹¤íŒ¨', false);
                }
            }

            setupEventListeners() {
                const symbolSelect = document.getElementById('symbolSelect');
                symbolSelect.addEventListener('change', (e) => {
                    if (e.target.value) {
                        this.onSymbolChange(e.target.value);
                    }
                });
            }

            initializeCharts() {
                // ê°€ê²© ì°¨íŠ¸ ì´ˆê¸°í™”
                this.priceChart = LightweightCharts.createChart(document.getElementById('priceChart'), {
                    width: document.getElementById('priceChart').offsetWidth,
                    height: 400,
                    layout: {
                        background: { color: '#1e2329' },
                        textColor: '#d1d4dc',
                    },
                    grid: {
                        vertLines: { color: '#2b3139' },
                        horzLines: { color: '#2b3139' },
                    },
                    crosshair: {
                        mode: LightweightCharts.CrosshairMode.Normal,
                    },
                    rightPriceScale: {
                        borderColor: '#485158',
                    },
                    timeScale: {
                        borderColor: '#485158',
                        timeVisible: true,
                        secondsVisible: false,
                    },
                });

                this.candlestickSeries = this.priceChart.addSeries(LightweightCharts.CandlestickSeries, {
                    upColor: '#02c076',
                    downColor: '#f84960',
                    borderDownColor: '#f84960',
                    borderUpColor: '#02c076',
                    wickDownColor: '#f84960',
                    wickUpColor: '#02c076',
                });

                // í…Œì´ì»¤ ë¹„ìœ¨ ì°¨íŠ¸ ì´ˆê¸°í™”
                this.ratioChart = LightweightCharts.createChart(document.getElementById('ratioChart'), {
                    width: document.getElementById('ratioChart').offsetWidth,
                    height: 200,
                    layout: {
                        background: { color: '#1e2329' },
                        textColor: '#d1d4dc',
                    },
                    grid: {
                        vertLines: { color: '#2b3139' },
                        horzLines: { color: '#2b3139' },
                    },
                    crosshair: {
                        mode: LightweightCharts.CrosshairMode.Normal,
                    },
                    rightPriceScale: {
                        borderColor: '#485158',
                        scaleMargins: {
                            top: 0.1,
                            bottom: 0.1,
                        },
                    },
                    timeScale: {
                        borderColor: '#485158',
                        timeVisible: true,
                        secondsVisible: false,
                    },
                });

                this.ratioSeries = this.ratioChart.addSeries(LightweightCharts.LineSeries, {
                    color: '#f0b90b',
                    lineWidth: 2,
                    priceFormat: {
                        type: 'custom',
                        minMove: 0.001,
                        formatter: (price) => {
                            return (price * 100).toFixed(1) + '%';
                        },
                    },
                });

                // ê±°ë˜ëŸ‰ ì°¨íŠ¸ ì´ˆê¸°í™”
                this.volumeChart = LightweightCharts.createChart(document.getElementById('volumeChart'), {
                    width: document.getElementById('volumeChart').offsetWidth,
                    height: 200,
                    layout: {
                        background: { color: '#1e2329' },
                        textColor: '#d1d4dc',
                    },
                    grid: {
                        vertLines: { color: '#2b3139' },
                        horzLines: { color: '#2b3139' },
                    },
                    crosshair: {
                        mode: LightweightCharts.CrosshairMode.Normal,
                    },
                    rightPriceScale: {
                        borderColor: '#485158',
                        scaleMargins: {
                            top: 0.1,
                            bottom: 0.1,
                        },
                    },
                    timeScale: {
                        borderColor: '#485158',
                        timeVisible: true,
                        secondsVisible: false,
                    },
                });

                // í…Œì´ì»¤ ê±°ë˜ëŸ‰ ì‹œë¦¬ì¦ˆ (ë§¤ìˆ˜ì)
                this.takerVolumeSeries = this.volumeChart.addSeries(LightweightCharts.HistogramSeries, {
                    color: '#02c076',
                    priceFormat: {
                        type: 'volume',
                    },
                });

                // ë§ˆì¼“ë©”ì´ì»¤ ê±°ë˜ëŸ‰ ì‹œë¦¬ì¦ˆ (ë§¤ë„ì) - ìŒìˆ˜ë¡œ í‘œì‹œ
                this.makerVolumeSeries = this.volumeChart.addSeries(LightweightCharts.HistogramSeries, {
                    color: '#f84960',
                    priceFormat: {
                        type: 'volume',
                    },
                });

                // ê°•ì œì²­ì‚° ì°¨íŠ¸ ì´ˆê¸°í™”
                this.liquidationChart = LightweightCharts.createChart(document.getElementById('liquidationChart'), {
                    width: document.getElementById('liquidationChart').offsetWidth,
                    height: 150,
                    layout: {
                        background: { color: '#1e2329' },
                        textColor: '#d1d4dc',
                    },
                    grid: {
                        vertLines: { color: '#2b3139' },
                        horzLines: { color: '#2b3139' },
                    },
                    crosshair: {
                        mode: LightweightCharts.CrosshairMode.Normal,
                    },
                    rightPriceScale: {
                        borderColor: '#485158',
                        scaleMargins: {
                            top: 0.1,
                            bottom: 0.1,
                        },
                    },
                    timeScale: {
                        borderColor: '#485158',
                        timeVisible: true,
                        secondsVisible: false,
                    },
                });

                // LONG í¬ì§€ì…˜ ê°•ì œì²­ì‚° ì‹œë¦¬ì¦ˆ (ë¹¨ê°„ìƒ‰, ìŒìˆ˜ë¡œ í‘œì‹œ)
                this.longLiquidationSeries = this.liquidationChart.addSeries(LightweightCharts.HistogramSeries, {
                    color: '#f84960',
                    priceFormat: {
                        type: 'volume',
                    },
                });

                // SHORT í¬ì§€ì…˜ ê°•ì œì²­ì‚° ì‹œë¦¬ì¦ˆ (ì´ˆë¡ìƒ‰, ì–‘ìˆ˜ë¡œ í‘œì‹œ)
                this.shortLiquidationSeries = this.liquidationChart.addSeries(LightweightCharts.HistogramSeries, {
                    color: '#02c076',
                    priceFormat: {
                        type: 'volume',
                    },
                });

                // ì°¨íŠ¸ ì‹œê°„ì¶• ë™ê¸°í™” ì„¤ì •
                this.setupTimeScaleSync();

                // ì°¨íŠ¸ ë¦¬ì‚¬ì´ì¦ˆ ì²˜ë¦¬
                window.addEventListener('resize', () => {
                    if (this.priceChart) {
                        this.priceChart.applyOptions({
                            width: document.getElementById('priceChart').offsetWidth
                        });
                    }
                    if (this.volumeChart) {
                        this.volumeChart.applyOptions({
                            width: document.getElementById('volumeChart').offsetWidth
                        });
                    }
                    if (this.ratioChart) {
                        this.ratioChart.applyOptions({
                            width: document.getElementById('ratioChart').offsetWidth
                        });
                    }
                });
            }

            setupTimeScaleSync() {
                // ê¸°ì¡´ ë™ê¸°í™” í•´ì œ
                this.cleanupTimeScaleSync();
                
                // ì‹œê°„ì¶• ë™ê¸°í™”ë¥¼ ìœ„í•œ ë³€ìˆ˜ë“¤
                this.isSyncing = false;
                this.charts = [
                    { chart: this.priceChart, name: 'price' },
                    { chart: this.volumeChart, name: 'volume' },
                    { chart: this.ratioChart, name: 'ratio' },
                    { chart: this.liquidationChart, name: 'liquidation' }
                ];
                this.syncIntervals = [];
                
                // ê° ì°¨íŠ¸ì— ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
                this.charts.forEach((chartInfo, index) => {
                    const chart = chartInfo.chart;
                    if (chart && chart.timeScale) {
                        const chartElement = chart.chartElement ? chart.chartElement() : 
                                           document.getElementById(chartInfo.name === 'price' ? 'priceChart' : 
                                                                 chartInfo.name === 'volume' ? 'volumeChart' : 
                                                                 chartInfo.name === 'ratio' ? 'ratioChart' : 'liquidationChart');
                        
                        if (chartElement) {
                            // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ë¡œ ì‹œê°„ì¶• ë³€ê²½ ê°ì§€
                            const syncHandler = () => {
                                if (this.isSyncing) return;
                                
                                this.isSyncing = true;
                                
                                try {
                                    const visibleRange = chart.timeScale().getVisibleLogicalRange();
                                    if (visibleRange) {
                                        // ë‹¤ë¥¸ ì°¨íŠ¸ë“¤ì— ë™ì¼í•œ ë²”ìœ„ ì ìš©
                                        this.charts.forEach((otherChartInfo, otherIndex) => {
                                            if (otherIndex !== index && otherChartInfo.chart && otherChartInfo.chart.timeScale) {
                                                try {
                                                    otherChartInfo.chart.timeScale().setVisibleLogicalRange(visibleRange);
                                                } catch (error) {
                                                    console.debug(`${otherChartInfo.name} ì°¨íŠ¸ ë™ê¸°í™” ì‹¤íŒ¨:`, error.message);
                                                }
                                            }
                                        });
                                    }
                                } catch (error) {
                                    console.debug('ì‹œê°„ì¶• ë²”ìœ„ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨:', error.message);
                                }
                                
                                setTimeout(() => {
                                    this.isSyncing = false;
                                }, 50);
                            };
                            
                            // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ ë“±ë¡
                            chartElement.addEventListener('wheel', syncHandler);
                            chartElement.addEventListener('mouseup', syncHandler);
                            chartElement.addEventListener('touchend', syncHandler);
                            
                            // ì •ë¦¬ë¥¼ ìœ„í•´ ì €ì¥
                            this.syncIntervals.push({
                                element: chartElement,
                                handler: syncHandler,
                                cleanup: () => {
                                    chartElement.removeEventListener('wheel', syncHandler);
                                    chartElement.removeEventListener('mouseup', syncHandler);
                                    chartElement.removeEventListener('touchend', syncHandler);
                                }
                            });
                        }
                    }
                });
                
                console.log('ì°¨íŠ¸ ì‹œê°„ì¶• ë™ê¸°í™” ì„¤ì • ì™„ë£Œ (Context7 í˜¸í™˜)');
            }

            cleanupTimeScaleSync() {
                // ê¸°ì¡´ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ í•´ì œ
                if (this.syncIntervals && this.syncIntervals.length > 0) {
                    this.syncIntervals.forEach(syncInfo => {
                        if (syncInfo.cleanup && typeof syncInfo.cleanup === 'function') {
                            syncInfo.cleanup();
                        }
                    });
                    this.syncIntervals = [];
                    console.log('ì‹œê°„ì¶• ë™ê¸°í™” ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ í•´ì œ ì™„ë£Œ');
                }
                
                // ì´ì „ êµ¬ë… ë°©ì‹ë„ ì •ë¦¬ (í•˜ìœ„ í˜¸í™˜ì„±)
                if (this.timeScaleSubscriptions && this.timeScaleSubscriptions.length > 0) {
                    this.timeScaleSubscriptions.forEach(unsubscribe => {
                        if (typeof unsubscribe === 'function') {
                            unsubscribe();
                        }
                    });
                    this.timeScaleSubscriptions = [];
                }
            }

            async onSymbolChange(symbol) {
                if (this.currentSymbol === symbol || this.isConnecting) return;
                
                // ì—°ê²° ì¤‘ ìƒíƒœë¡œ ì„¤ì •
                this.isConnecting = true;
                
                // ì´ì „ ì‹¬ë³¼ ì •ë¦¬
                await this.cleanupPreviousSymbol();
                
                this.currentSymbol = symbol;
                document.getElementById('stats').style.display = 'none';
                this.updateStatus('ê³¼ê±° ë°ì´í„° ë¡œë”© ì¤‘...', false);
                
                try {
                    // ê³¼ê±° ë°ì´í„° ë¨¼ì € ë¡œë“œ
                    await this.loadHistoricalData();
                    
                    this.updateStatus('ì‹¤ì‹œê°„ ì—°ê²° ì¤‘...', false);
                    await this.connectWebSockets();
                    
                    // ì‹œê°„ì¶• ë™ê¸°í™” ì¬ì„¤ì •
                    this.setupTimeScaleSync();
                    
                } catch (error) {
                    console.error('ì‹¬ë³¼ ë³€ê²½ ì˜¤ë¥˜:', error);
                    this.updateStatus('ì—°ê²° ì‹¤íŒ¨', false);
                } finally {
                    this.isConnecting = false;
                }
            }

            async cleanupPreviousSymbol() {
                // ëª¨ë“  ì¬ì—°ê²° íƒ€ì´ë¨¸ ì·¨ì†Œ
                this.reconnectTimeouts.forEach(timeoutId => {
                    clearTimeout(timeoutId);
                });
                this.reconnectTimeouts.clear();
                
                // WebSocket ì—°ê²° ì •ë¦¬
                this.closeWebSockets();
                
                // ì‹œê°„ì¶• ë™ê¸°í™” í•´ì œ
                this.cleanupTimeScaleSync();
                
                // ì°¨íŠ¸ ë°ì´í„° ì •ë¦¬
                this.clearCharts();
                
                // ìƒíƒœ ë°ì´í„° ì´ˆê¸°í™”
                this.resetMinuteData();
                this.reconnectAttempts = 0;
                
                // ì•½ê°„ì˜ ì§€ì—°ì„ ë‘ì–´ ì´ì „ ì—°ê²°ì´ ì™„ì „íˆ ì •ë¦¬ë˜ë„ë¡ í•¨
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            async loadHistoricalData() {
                if (!this.currentSymbol) return;

                try {
                    // ê³¼ê±° 1ë¶„ ìº”ë“¤ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (ìµœê·¼ 100ë¶„)
                    const klineResponse = await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${this.currentSymbol}&interval=1m&limit=100`);
                    const klineData = await klineResponse.json();
                    
                    console.log('ê°€ê²© ì°¨íŠ¸ ë°ì´í„°:', klineData.length, 'ê°œ ìº”ë“¤ ë¡œë”©');

                    // ìº”ë“¤ ë°ì´í„° ë³€í™˜ ë° ì„¤ì •
                    const candleData = klineData.map(kline => ({
                        time: Math.floor(kline[0] / 1000),
                        open: parseFloat(kline[1]),
                        high: parseFloat(kline[2]),
                        low: parseFloat(kline[3]),
                        close: parseFloat(kline[4])
                    }));

                    if (this.candlestickSeries && candleData.length > 0) {
                        this.candlestickSeries.setData(candleData);
                        
                        // ì°¨íŠ¸ ì‹œê°„ì¶•ì„ ë§ì¶¤
                        this.priceChart.timeScale().fitContent();
                        
                        // ë§ˆì§€ë§‰ ìº”ë“¤ ì •ë³´ë¡œ í†µê³„ ì—…ë°ì´íŠ¸
                        const lastCandle = candleData[candleData.length - 1];
                        this.updateStatsFromCandle(lastCandle);
                    }

                    // ê³¼ê±° í…Œì´ì»¤ ë¹„ìœ¨ ë°ì´í„° ìƒì„± (ìµœê·¼ 10ë¶„ë§Œ)
                    console.log('í…Œì´ì»¤ ë¹„ìœ¨ ë°ì´í„°:', candleData.length, 'ê°œ í¬ì¸íŠ¸ ìƒì„±');
                    const ratioData = candleData.map(candle => {
                        // ê°€ê²© ë³€ë™ì„±ì„ ê¸°ë°˜ìœ¼ë¡œ í•œ í…Œì´ì»¤ ë¹„ìœ¨ ì¶”ì •
                        const priceChange = (candle.close - candle.open) / candle.open;
                        const volatility = (candle.high - candle.low) / candle.open;
                        
                        // ê¸°ë³¸ ë¹„ìœ¨ (ìƒìŠ¹ë´‰ì€ ë§¤ìˆ˜ ìš°ì„¸, í•˜ë½ë´‰ì€ ë§¤ë„ ìš°ì„¸)
                        let baseRatio = candle.close > candle.open ? 
                            0.52 + Math.random() * 0.15 : // ìƒìŠ¹ë´‰ì¼ ë•Œ 0.52-0.67
                            0.33 + Math.random() * 0.15;  // í•˜ë½ë´‰ì¼ ë•Œ 0.33-0.48
                        
                        // ë³€ë™ì„±ì„ ê³ ë ¤í•œ ê³ ê°€/ì €ê°€ ìƒì„±
                        const ratioVolatility = Math.min(0.1, volatility * 2); // ìµœëŒ€ 10% ë³€ë™
                        
                        const open = Math.max(0.1, Math.min(0.9, baseRatio + (Math.random() - 0.5) * 0.05));
                        const close = Math.max(0.1, Math.min(0.9, baseRatio + (Math.random() - 0.5) * 0.05));
                        const high = Math.max(open, close) + Math.random() * ratioVolatility;
                        const low = Math.min(open, close) - Math.random() * ratioVolatility;
                        
                        return {
                            time: candle.time,
                            value: Math.max(0.05, Math.min(0.95, close)) // ë¼ì¸ ì°¨íŠ¸ëŠ” valueë§Œ í•„ìš”
                        };
                    });

                    if (this.ratioSeries && ratioData.length > 0) {
                        this.ratioSeries.setData(ratioData);
                        this.ratioChart.timeScale().fitContent();
                    }

                    // ê³¼ê±° ê±°ë˜ëŸ‰ ë°ì´í„° ë¡œë”© (ê°€ê²© ì°¨íŠ¸ ë°ì´í„°ì™€ í•¨ê»˜)
                    await this.loadHistoricalVolumeData(candleData);

                } catch (error) {
                    console.error('ê³¼ê±° ë°ì´í„° ë¡œë”© ì‹¤íŒ¨:', error);
                    this.updateStatus('ê³¼ê±° ë°ì´í„° ë¡œë”© ì‹¤íŒ¨', false);
                }
            }

            async loadHistoricalVolumeData(candleData) {
                if (!this.currentSymbol) return;

                try {
                    // ê°€ì¥ ìµœê·¼ ê±°ë˜ ë°ì´í„°ë§Œ ê°€ì ¸ì˜¤ê¸° (limit 1000 ìµœëŒ€ì¹˜ í™œìš©)
                    console.log('ìµœê·¼ ê±°ë˜ëŸ‰ ë°ì´í„° ë¡œë”© ì¤‘... (ìµœëŒ€ 1000ê°œ ê±°ë˜)');
                    
                    const tradesResponse = await fetch(`https://fapi.binance.com/fapi/v1/aggTrades?symbol=${this.currentSymbol}&limit=1000`);
                    const tradesData = await tradesResponse.json();
                    
                    console.log('ë°›ì€ ê±°ë˜ ë°ì´í„° ê°œìˆ˜:', tradesData.length);
                    if (tradesData.length > 0) {
                        console.log('ì²« ê±°ë˜:', new Date(tradesData[0].T));
                        console.log('ë§ˆì§€ë§‰ ê±°ë˜:', new Date(tradesData[tradesData.length - 1].T));
                        
                        const timeRange = (tradesData[tradesData.length - 1].T - tradesData[0].T) / 60000;
                        console.log('ë°ì´í„° ì‹œê°„ ë²”ìœ„:', timeRange.toFixed(1), 'ë¶„');
                    }

                    // ë¶„ ë‹¨ìœ„ë¡œ ê±°ë˜ëŸ‰ ê·¸ë£¹í™”
                    const volumeByMinute = {};
                    
                    tradesData.forEach(trade => {
                        const minute = Math.floor(trade.T / 60000) * 60000;
                        const volume = parseFloat(trade.q);
                        
                        if (!volumeByMinute[minute]) {
                            volumeByMinute[minute] = {
                                takerVolume: 0,
                                makerVolume: 0
                            };
                        }
                        
                        if (!trade.m) { // í…Œì´ì»¤ê°€ ë§¤ìˆ˜ì
                            volumeByMinute[minute].takerVolume += volume;
                        } else { // ë§ˆì¼“ë©”ì´ì»¤ê°€ ë§¤ìˆ˜ì (í…Œì´ì»¤ëŠ” ë§¤ë„ì)
                            volumeByMinute[minute].makerVolume += volume;
                        }
                    });

                    // ì°¨íŠ¸ ë°ì´í„°ë¡œ ë³€í™˜
                    const takerVolumeData = [];
                    const makerVolumeData = [];
                    
                    Object.keys(volumeByMinute).sort((a, b) => a - b).forEach(minute => {
                        const time = Math.floor(minute / 1000);
                        const data = volumeByMinute[minute];
                        
                        takerVolumeData.push({
                            time: time,
                            value: data.takerVolume
                        });
                        
                        makerVolumeData.push({
                            time: time,
                            value: -data.makerVolume // ìŒìˆ˜ë¡œ í‘œì‹œ
                        });
                    });

                    // ê°€ê²© ì°¨íŠ¸ì™€ ë™ì¼í•œ ì‹œê°„ ë²”ìœ„ë¡œ ê±°ë˜ëŸ‰ ë°ì´í„° ìƒì„± (ì‹¤ì œ ë°ì´í„° + 0 ì±„ìš°ê¸°)
                    this.fillInitialVolumeData(candleData, volumeByMinute);
                    
                    if (this.volumeChart) {
                        this.volumeChart.timeScale().fitContent();
                    }

                    // ë§ˆì§€ë§‰ ë¶„ì˜ ê±°ë˜ëŸ‰ ë°ì´í„°ë¥¼ currentVolumeDataì— ì„¤ì •í•˜ì—¬ ì‹¤ì‹œê°„ ë°ì´í„°ì™€ ì—°ê²°
                    const sortedMinutes = Object.keys(volumeByMinute).sort((a, b) => b - a);
                    if (sortedMinutes.length > 0) {
                        const lastMinute = parseInt(sortedMinutes[0]);
                        const lastVolumeData = volumeByMinute[lastMinute];
                        
                        // ì‹¤ì‹œê°„ ë°ì´í„°ëŠ” í•­ìƒ ìƒˆë¡œ ì‹œì‘ (ê³¼ê±° ë°ì´í„°ì™€ ì—°ê²°í•˜ì§€ ì•ŠìŒ)
                        const realCurrentMinute = Math.floor(Date.now() / 60000) * 60000;
                        const timeDiff = realCurrentMinute - lastMinute;
                        
                        console.log('ê³¼ê±° ê±°ë˜ëŸ‰ ë°ì´í„° ë¡œë”© ì™„ë£Œ');
                        console.log('- ë§ˆì§€ë§‰ ë¶„:', new Date(lastMinute));
                        console.log('- í˜„ì¬ ë¶„:', new Date(realCurrentMinute));
                        console.log('- ì‹œê°„ ì°¨ì´:', Math.floor(timeDiff / 60000), 'ë¶„');
                        console.log('ì‹¤ì‹œê°„ ë°ì´í„°ëŠ” ìƒˆë¡œìš´ ë´‰ë¶€í„° 0ìœ¼ë¡œ ì‹œì‘ë©ë‹ˆë‹¤.');
                    }

                } catch (error) {
                    console.error('ê³¼ê±° ë°ì´í„° ë¡œë”© ì‹¤íŒ¨:', error);
                    this.updateStatus('ê³¼ê±° ë°ì´í„° ë¡œë”© ì‹¤íŒ¨', false);
                }
            }

            fillInitialVolumeData(candleData, volumeByMinute) {
                // ê°€ê²© ì°¨íŠ¸ì™€ ë™ì¼í•œ ì‹œê°„ ë²”ìœ„ë¡œ ê±°ë˜ëŸ‰ ë°ì´í„° ìƒì„±
                if (!candleData || candleData.length === 0) return;
                
                const takerVolumeData = [];
                const makerVolumeData = [];
                
                // ê°€ê²© ì°¨íŠ¸ì˜ ê° ìº”ë“¤ì— ëŒ€ì‘í•˜ëŠ” ê±°ë˜ëŸ‰ ë°ì´í„° ìƒì„±
                candleData.forEach(candle => {
                    const candleTime = candle.time;
                    const candleMinute = candleTime * 1000; // ë°€ë¦¬ì´ˆë¡œ ë³€í™˜
                    
                    // í•´ë‹¹ ì‹œê°„ì˜ ì‹¤ì œ ê±°ë˜ëŸ‰ ë°ì´í„°ê°€ ìˆëŠ”ì§€ í™•ì¸
                    const volumeData = volumeByMinute[candleMinute];
                    
                    if (volumeData) {
                        // ì‹¤ì œ ë°ì´í„°ê°€ ìˆìœ¼ë©´ ì‚¬ìš©
                        takerVolumeData.push({
                            time: candleTime,
                            value: volumeData.takerVolume
                        });
                        
                        makerVolumeData.push({
                            time: candleTime,
                            value: -volumeData.makerVolume // ìŒìˆ˜ë¡œ í‘œì‹œ
                        });
                    } else {
                        // ë°ì´í„°ê°€ ì—†ìœ¼ë©´ 0ìœ¼ë¡œ ì±„ìš°ê¸°
                        takerVolumeData.push({
                            time: candleTime,
                            value: 0
                        });
                        
                        makerVolumeData.push({
                            time: candleTime,
                            value: 0
                        });
                    }
                });
                
                // ê±°ë˜ëŸ‰ ì°¨íŠ¸ì— ë°ì´í„° ì„¤ì • (ì‹¤ì œ ë°ì´í„° + 0 ì±„ìš°ê¸°)
                if (this.takerVolumeSeries) {
                    this.takerVolumeSeries.setData(takerVolumeData);
                    console.log('í…Œì´ì»¤ ê±°ë˜ëŸ‰ ì°¨íŠ¸ ë°ì´í„° ì„¤ì • ì™„ë£Œ:', takerVolumeData.length, 'ê°œ ë´‰');
                }
                
                if (this.makerVolumeSeries) {
                    this.makerVolumeSeries.setData(makerVolumeData);
                    console.log('ë§ˆì¼“ë©”ì´ì»¤ ê±°ë˜ëŸ‰ ì°¨íŠ¸ ë°ì´í„° ì„¤ì • ì™„ë£Œ:', makerVolumeData.length, 'ê°œ ë´‰');
                }
                
                // ê°•ì œì²­ì‚° ì°¨íŠ¸ë„ ë™ì¼í•œ ì‹œê°„ ë²”ìœ„ë¡œ 0 ë°ì´í„° ìƒì„±
                const longLiquidationData = [];
                const shortLiquidationData = [];
                
                candleData.forEach(candle => {
                    longLiquidationData.push({
                        time: candle.time,
                        value: 0
                    });
                    
                    shortLiquidationData.push({
                        time: candle.time,
                        value: 0
                    });
                });
                
                // ê°•ì œì²­ì‚° ì°¨íŠ¸ì— 0 ë°ì´í„° ì„¤ì •
                if (this.longLiquidationSeries) {
                    this.longLiquidationSeries.setData(longLiquidationData);
                    console.log('LONG ê°•ì œì²­ì‚° ì°¨íŠ¸ ë°ì´í„° ì„¤ì • ì™„ë£Œ:', longLiquidationData.length, 'ê°œ ë´‰');
                }
                
                if (this.shortLiquidationSeries) {
                    this.shortLiquidationSeries.setData(shortLiquidationData);
                    console.log('SHORT ê°•ì œì²­ì‚° ì°¨íŠ¸ ë°ì´í„° ì„¤ì • ì™„ë£Œ:', shortLiquidationData.length, 'ê°œ ë´‰');
                }
                
                const firstTime = candleData[0].time;
                const lastTime = candleData[candleData.length - 1].time;
                console.log('ê±°ë˜ëŸ‰ ë° ê°•ì œì²­ì‚° ì°¨íŠ¸ ì‹œê°„ ë²”ìœ„ ì„¤ì •:', new Date(firstTime * 1000), '~', new Date(lastTime * 1000));
            }

            async connectWebSockets() {
                if (!this.currentSymbol) return;

                const symbol = this.currentSymbol.toLowerCase();
                
                // ì—°ê²° ì¤‘ ìƒíƒœ í™•ì¸
                if (this.priceWs || this.tradeWs || this.liquidationWs) {
                    console.warn('WebSocketì´ ì´ë¯¸ ì—°ê²°ë˜ì–´ ìˆìŠµë‹ˆë‹¤.');
                    return;
                }
                
                try {
                    // ê°€ê²© WebSocket ì—°ê²°
                    await this.connectPriceWebSocket(symbol);
                    
                    // ê±°ë˜ WebSocket ì—°ê²°
                    await this.connectTradeWebSocket(symbol);
                    
                    // ê°•ì œì²­ì‚° WebSocket ì—°ê²°
                    await this.connectLiquidationWebSocket(symbol);
                    
                } catch (error) {
                    console.error('WebSocket ì—°ê²° ì‹¤íŒ¨:', error);
                    this.updateStatus('ì—°ê²° ì‹¤íŒ¨', false);
                }
            }

            connectPriceWebSocket(symbol) {
                return new Promise((resolve, reject) => {
                    const wsUrl = `wss://fstream.binance.com/stream?streams=${symbol}@kline_1m`;
                    
                    this.priceWs = new WebSocket(wsUrl);
                    
                    const connectionTimeout = setTimeout(() => {
                        if (this.priceWs && this.priceWs.readyState === WebSocket.CONNECTING) {
                            this.priceWs.close();
                            reject(new Error('ê°€ê²© WebSocket ì—°ê²° íƒ€ì„ì•„ì›ƒ'));
                        }
                    }, 10000); // 10ì´ˆ íƒ€ì„ì•„ì›ƒ
                    
                    this.priceWs.onopen = () => {
                        clearTimeout(connectionTimeout);
                        console.log('ê°€ê²© WebSocket ì—°ê²°ë¨');
                        this.reconnectAttempts = 0;
                        this.updateStatus('ì—°ê²°ë¨', true);
                        resolve();
                    };
                    
                    this.priceWs.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            if (data.data && data.data.k && data.data.k.s === this.currentSymbol) {
                                this.handleKlineData(data.data.k);
                            }
                        } catch (error) {
                            console.error('ê°€ê²© ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜:', error);
                        }
                    };
                    
                    this.priceWs.onclose = (event) => {
                        clearTimeout(connectionTimeout);
                        console.log('ê°€ê²© WebSocket ì—°ê²° ì¢…ë£Œ:', event.code, event.reason);
                        if (!this.isConnecting) { // ì‹¬ë³¼ ë³€ê²½ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ ì¬ì—°ê²°
                            this.updateStatus('ì—°ê²° ëŠê¹€', false);
                            this.scheduleReconnect('price');
                        }
                    };
                    
                    this.priceWs.onerror = (error) => {
                        clearTimeout(connectionTimeout);
                        console.error('ê°€ê²© WebSocket ì˜¤ë¥˜:', error);
                        this.updateStatus('ì—°ê²° ì˜¤ë¥˜', false);
                        reject(error);
                    };
                });
            }

            connectTradeWebSocket(symbol) {
                return new Promise((resolve, reject) => {
                    const wsUrl = `wss://fstream.binance.com/stream?streams=${symbol}@aggTrade`;
                    
                    this.tradeWs = new WebSocket(wsUrl);
                    
                    const connectionTimeout = setTimeout(() => {
                        if (this.tradeWs && this.tradeWs.readyState === WebSocket.CONNECTING) {
                            this.tradeWs.close();
                            reject(new Error('ê±°ë˜ WebSocket ì—°ê²° íƒ€ì„ì•„ì›ƒ'));
                        }
                    }, 10000); // 10ì´ˆ íƒ€ì„ì•„ì›ƒ
                    
                    this.tradeWs.onopen = () => {
                        clearTimeout(connectionTimeout);
                        console.log('ê±°ë˜ WebSocket ì—°ê²°ë¨');
                        resolve();
                    };
                    
                    this.tradeWs.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            if (data.data && data.data.s === this.currentSymbol) {
                                this.handleTradeData(data.data);
                            }
                        } catch (error) {
                            console.error('ê±°ë˜ ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜:', error);
                        }
                    };
                    
                    this.tradeWs.onclose = (event) => {
                        clearTimeout(connectionTimeout);
                        console.log('ê±°ë˜ WebSocket ì—°ê²° ì¢…ë£Œ:', event.code, event.reason);
                        if (!this.isConnecting) { // ì‹¬ë³¼ ë³€ê²½ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ ì¬ì—°ê²°
                            this.scheduleReconnect('trade');
                        }
                    };
                    
                    this.tradeWs.onerror = (error) => {
                        clearTimeout(connectionTimeout);
                        console.error('ê±°ë˜ WebSocket ì˜¤ë¥˜:', error);
                        reject(error);
                    };
                });
            }

            connectLiquidationWebSocket(symbol) {
                return new Promise((resolve, reject) => {
                    const wsUrl = `wss://fstream.binance.com/stream?streams=${symbol}@forceOrder`;
                    
                    this.liquidationWs = new WebSocket(wsUrl);
                    
                    const connectionTimeout = setTimeout(() => {
                        if (this.liquidationWs && this.liquidationWs.readyState === WebSocket.CONNECTING) {
                            this.liquidationWs.close();
                            reject(new Error('ê°•ì œì²­ì‚° WebSocket ì—°ê²° íƒ€ì„ì•„ì›ƒ'));
                        }
                    }, 10000); // 10ì´ˆ íƒ€ì„ì•„ì›ƒ
                    
                    this.liquidationWs.onopen = () => {
                        clearTimeout(connectionTimeout);
                        console.log('ê°•ì œì²­ì‚° WebSocket ì—°ê²°ë¨');
                        resolve();
                    };
                    
                    this.liquidationWs.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            if (data.data && data.data.o && data.data.o.s === this.currentSymbol) {
                                this.handleLiquidationData(data.data.o);
                            }
                        } catch (error) {
                            console.error('ê°•ì œì²­ì‚° ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜:', error);
                        }
                    };
                    
                    this.liquidationWs.onclose = (event) => {
                        clearTimeout(connectionTimeout);
                        console.log('ê°•ì œì²­ì‚° WebSocket ì—°ê²° ì¢…ë£Œ:', event.code, event.reason);
                        if (!this.isConnecting) { // ì‹¬ë³¼ ë³€ê²½ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ ì¬ì—°ê²°
                            this.scheduleReconnect('liquidation');
                        }
                    };
                    
                    this.liquidationWs.onerror = (error) => {
                        clearTimeout(connectionTimeout);
                        console.error('ê°•ì œì²­ì‚° WebSocket ì˜¤ë¥˜:', error);
                        reject(error);
                    };
                });
            }

            handleKlineData(kline) {
                const candle = {
                    time: Math.floor(kline.t / 1000),
                    open: parseFloat(kline.o),
                    high: parseFloat(kline.h),
                    low: parseFloat(kline.l),
                    close: parseFloat(kline.c)
                };

                if (this.candlestickSeries) {
                    this.candlestickSeries.update(candle);
                }

                // kline ë°ì´í„°ì—ì„œ í…Œì´ì»¤ ë¹„ìœ¨ ì •ë³´ ì¶”ì¶œ ë° ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
                this.updateRealTimeRatio(kline);

                // í†µê³„ ì—…ë°ì´íŠ¸
                this.updateStats(kline);

                // ë¡œë”© ìƒíƒœ ì œê±°
                document.getElementById('stats').style.display = 'grid';
                const loadingElements = document.querySelectorAll('.loading');
                loadingElements.forEach(el => el.style.display = 'none');
            }

            updateRealTimeRatio(kline) {
                // kline ë°ì´í„°ì—ì„œ í…Œì´ì»¤ ë§¤ìˆ˜ ë¹„ìœ¨ ê³„ì‚°
                const takerBuyQuoteVolume = parseFloat(kline.Q); // í…Œì´ì»¤ ë§¤ìˆ˜ ê±°ë˜ëŸ‰ (USDT)
                const totalQuoteVolume = parseFloat(kline.q);    // ì „ì²´ ê±°ë˜ëŸ‰ (USDT)
                
                if (totalQuoteVolume > 0) {
                    const ratio = takerBuyQuoteVolume / totalQuoteVolume;
                    const currentTime = Math.floor(kline.t / 1000);
                    
                    // ë¼ì¸ ì°¨íŠ¸ ì—…ë°ì´íŠ¸
                    if (this.ratioSeries) {
                        this.ratioSeries.update({
                            time: currentTime,
                            value: ratio
                        });
                    }

                    // í˜„ì¬ ë¹„ìœ¨ í†µê³„ ì—…ë°ì´íŠ¸
                    const currentRatioElement = document.getElementById('currentRatio');
                    if (currentRatioElement) {
                        currentRatioElement.textContent = `${(ratio * 100).toFixed(1)}%`;
                        currentRatioElement.className = `stat-value ${ratio > 0.5 ? 'positive' : 'negative'}`;
                    }
                }
            }

            handleTradeData(trade) {
                const tradeTime = trade.T;
                const currentMinute = Math.floor(tradeTime / 60000) * 60000;
                const volume = parseFloat(trade.q);
                
                // ìƒˆë¡œìš´ ë¶„ì´ ì‹œì‘ë˜ë©´ ì´ì „ ë¶„ ë°ì´í„°ë¥¼ ì°¨íŠ¸ì— ì—…ë°ì´íŠ¸
                if (this.currentVolumeData.timestamp && this.currentVolumeData.timestamp !== currentMinute) {
                    this.updateVolumeChart();
                }
                
                // í˜„ì¬ ë¶„ ë°ì´í„° ì´ˆê¸°í™” ë˜ëŠ” ì—…ë°ì´íŠ¸
                if (this.currentVolumeData.timestamp !== currentMinute) {
                    // ìƒˆë¡œìš´ ë¶„ì´ ì‹œì‘ë˜ë©´ í•­ìƒ 0ìœ¼ë¡œ ì´ˆê¸°í™”
                    this.currentVolumeData = {
                        timestamp: currentMinute,
                        takerVolume: 0,
                        makerVolume: 0
                    };
                    console.log('ìƒˆë¡œìš´ ë¶„ ì‹œì‘ - ê±°ë˜ëŸ‰ 0ìœ¼ë¡œ ì´ˆê¸°í™”:', new Date(currentMinute));
                }
                
                // ê±°ë˜ëŸ‰ ëˆ„ì‚°
                if (!trade.m) { // í…Œì´ì»¤ê°€ ë§¤ìˆ˜ì
                    this.currentVolumeData.takerVolume += volume;
                } else { // ë§ˆì¼“ë©”ì´ì»¤ê°€ ë§¤ìˆ˜ì (í…Œì´ì»¤ëŠ” ë§¤ë„ì)
                    this.currentVolumeData.makerVolume += volume;
                }
                
                // ì‹¤ì‹œê°„ìœ¼ë¡œ í˜„ì¬ ë¶„ ê±°ë˜ëŸ‰ ì—…ë°ì´íŠ¸
                this.updateRealTimeVolume();
            }

            handleLiquidationData(liquidation) {
                const liquidationTime = liquidation.T;
                const currentMinute = Math.floor(liquidationTime / 60000) * 60000;
                const quantity = parseFloat(liquidation.z); // Order Filled Accumulated Quantity
                const side = liquidation.S; // Side: BUY or SELL
                
                console.log('ê°•ì œì²­ì‚° ë°ì´í„°:', {
                    symbol: liquidation.s,
                    side: side,
                    quantity: quantity,
                    price: liquidation.ap,
                    time: new Date(liquidationTime)
                });
                
                // ìƒˆë¡œìš´ ë¶„ì´ ì‹œì‘ë˜ë©´ ì´ì „ ë¶„ ë°ì´í„°ë¥¼ ì°¨íŠ¸ì— ì—…ë°ì´íŠ¸
                if (this.currentLiquidationData.timestamp && this.currentLiquidationData.timestamp !== currentMinute) {
                    this.updateLiquidationChart();
                }
                
                // í˜„ì¬ ë¶„ ë°ì´í„° ì´ˆê¸°í™” ë˜ëŠ” ì—…ë°ì´íŠ¸
                if (this.currentLiquidationData.timestamp !== currentMinute) {
                    // ìƒˆë¡œìš´ ë¶„ì´ ì‹œì‘ë˜ë©´ í•­ìƒ 0ìœ¼ë¡œ ì´ˆê¸°í™”
                    this.currentLiquidationData = {
                        timestamp: currentMinute,
                        longLiquidation: 0,  // LONG í¬ì§€ì…˜ ê°•ì œì²­ì‚° (SELL ì£¼ë¬¸)
                        shortLiquidation: 0  // SHORT í¬ì§€ì…˜ ê°•ì œì²­ì‚° (BUY ì£¼ë¬¸)
                    };
                    console.log('ìƒˆë¡œìš´ ë¶„ ì‹œì‘ - ê°•ì œì²­ì‚° 0ìœ¼ë¡œ ì´ˆê¸°í™”:', new Date(currentMinute));
                }
                
                // ê°•ì œì²­ì‚°ëŸ‰ ëˆ„ì‚°
                // SELL ì£¼ë¬¸ = LONG í¬ì§€ì…˜ ê°•ì œì²­ì‚°, BUY ì£¼ë¬¸ = SHORT í¬ì§€ì…˜ ê°•ì œì²­ì‚°
                if (side === 'SELL') {
                    this.currentLiquidationData.longLiquidation += quantity;
                } else if (side === 'BUY') {
                    this.currentLiquidationData.shortLiquidation += quantity;
                }
                
                // ì‹¤ì‹œê°„ìœ¼ë¡œ í˜„ì¬ ë¶„ ê°•ì œì²­ì‚°ëŸ‰ ì—…ë°ì´íŠ¸
                this.updateRealTimeLiquidation();
            }

            updateVolumeChart() {
                if (this.currentVolumeData.timestamp) {
                    const time = Math.floor(this.currentVolumeData.timestamp / 1000);
                    
                    if (this.takerVolumeSeries) {
                        this.takerVolumeSeries.update({
                            time: time,
                            value: this.currentVolumeData.takerVolume
                        });
                    }
                    
                    if (this.makerVolumeSeries) {
                        this.makerVolumeSeries.update({
                            time: time,
                            value: -this.currentVolumeData.makerVolume // ìŒìˆ˜ë¡œ í‘œì‹œ
                        });
                    }
                }
            }

            updateRealTimeVolume() {
                if (this.currentVolumeData.timestamp) {
                    const time = Math.floor(this.currentVolumeData.timestamp / 1000);
                    
                    // ì‹¤ì‹œê°„ìœ¼ë¡œ í˜„ì¬ ë¶„ ê±°ë˜ëŸ‰ ì—…ë°ì´íŠ¸
                    if (this.takerVolumeSeries) {
                        this.takerVolumeSeries.update({
                            time: time,
                            value: this.currentVolumeData.takerVolume
                        });
                    }
                    
                    if (this.makerVolumeSeries) {
                        this.makerVolumeSeries.update({
                            time: time,
                            value: -this.currentVolumeData.makerVolume // ìŒìˆ˜ë¡œ í‘œì‹œ
                        });
                    }
                }
            }

            updateLiquidationChart() {
                if (this.currentLiquidationData.timestamp) {
                    const time = Math.floor(this.currentLiquidationData.timestamp / 1000);
                    
                    if (this.shortLiquidationSeries) {
                        this.shortLiquidationSeries.update({
                            time: time,
                            value: this.currentLiquidationData.shortLiquidation
                        });
                    }
                    
                    if (this.longLiquidationSeries) {
                        this.longLiquidationSeries.update({
                            time: time,
                            value: -this.currentLiquidationData.longLiquidation // ìŒìˆ˜ë¡œ í‘œì‹œ
                        });
                    }
                }
            }

            updateRealTimeLiquidation() {
                if (this.currentLiquidationData.timestamp) {
                    const time = Math.floor(this.currentLiquidationData.timestamp / 1000);
                    
                    // ì‹¤ì‹œê°„ìœ¼ë¡œ í˜„ì¬ ë¶„ ê°•ì œì²­ì‚°ëŸ‰ ì—…ë°ì´íŠ¸
                    if (this.shortLiquidationSeries) {
                        this.shortLiquidationSeries.update({
                            time: time,
                            value: this.currentLiquidationData.shortLiquidation
                        });
                    }
                    
                    if (this.longLiquidationSeries) {
                        this.longLiquidationSeries.update({
                            time: time,
                            value: -this.currentLiquidationData.longLiquidation // ìŒìˆ˜ë¡œ í‘œì‹œ
                        });
                    }
                }
            }

            updateStatsFromCandle(candle) {
                // ê³¼ê±° ë°ì´í„° ë¡œë”©ì‹œ ì‚¬ìš©í•  í†µê³„ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
                const currentPrice = candle.close;
                const openPrice = candle.open;
                
                document.getElementById('currentPrice').textContent = `$${currentPrice.toLocaleString()}`;
                
                const priceChange = ((currentPrice - openPrice) / openPrice) * 100;
                const priceChangeElement = document.getElementById('priceChange');
                priceChangeElement.textContent = `${priceChange >= 0 ? '+' : ''}${priceChange.toFixed(2)}%`;
                priceChangeElement.className = `stat-value ${priceChange >= 0 ? 'positive' : 'negative'}`;
            }

            updateStats(kline) {
                const currentPrice = parseFloat(kline.c);
                const openPrice = parseFloat(kline.o);
                const volume = parseFloat(kline.q);
                
                document.getElementById('currentPrice').textContent = `$${currentPrice.toLocaleString()}`;
                
                const priceChange = ((currentPrice - openPrice) / openPrice) * 100;
                const priceChangeElement = document.getElementById('priceChange');
                priceChangeElement.textContent = `${priceChange >= 0 ? '+' : ''}${priceChange.toFixed(2)}%`;
                priceChangeElement.className = `stat-value ${priceChange >= 0 ? 'positive' : 'negative'}`;
                
                document.getElementById('volume').textContent = `$${(volume / 1000000).toFixed(1)}M`;
            }

            scheduleReconnect(type) {
                if (this.reconnectAttempts >= this.maxReconnectAttempts || this.isConnecting) {
                    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                        this.updateStatus('ì¬ì—°ê²° ì‹¤íŒ¨', false);
                    }
                    return;
                }
                
                this.reconnectAttempts++;
                const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);
                
                this.updateStatus(`ì¬ì—°ê²° ì¤‘... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`, false);
                
                const timeoutId = setTimeout(async () => {
                    this.reconnectTimeouts.delete(timeoutId);
                    
                    if (this.isConnecting || !this.currentSymbol) {
                        return; // ì‹¬ë³¼ ë³€ê²½ ì¤‘ì´ê±°ë‚˜ ì‹¬ë³¼ì´ ì—†ìœ¼ë©´ ì¬ì—°ê²° ì¤‘ë‹¨
                    }
                    
                    try {
                        if (type === 'price' && (!this.priceWs || this.priceWs.readyState !== WebSocket.OPEN)) {
                            await this.connectPriceWebSocket(this.currentSymbol.toLowerCase());
                        } else if (type === 'trade' && (!this.tradeWs || this.tradeWs.readyState !== WebSocket.OPEN)) {
                            await this.connectTradeWebSocket(this.currentSymbol.toLowerCase());
                        } else if (type === 'liquidation' && (!this.liquidationWs || this.liquidationWs.readyState !== WebSocket.OPEN)) {
                            await this.connectLiquidationWebSocket(this.currentSymbol.toLowerCase());
                        }
                    } catch (error) {
                        console.error(`${type} WebSocket ì¬ì—°ê²° ì‹¤íŒ¨:`, error);
                        this.scheduleReconnect(type); // ì¬ì‹œë„
                    }
                }, delay);
                
                this.reconnectTimeouts.add(timeoutId);
            }

            closeWebSockets() {
                // ê°€ê²© WebSocket ì •ë¦¬
                if (this.priceWs) {
                    this.priceWs.onopen = null;
                    this.priceWs.onmessage = null;
                    this.priceWs.onclose = null;
                    this.priceWs.onerror = null;
                    
                    if (this.priceWs.readyState === WebSocket.OPEN || 
                        this.priceWs.readyState === WebSocket.CONNECTING) {
                        this.priceWs.close();
                    }
                    this.priceWs = null;
                }
                
                // ê±°ë˜ WebSocket ì •ë¦¬
                if (this.tradeWs) {
                    this.tradeWs.onopen = null;
                    this.tradeWs.onmessage = null;
                    this.tradeWs.onclose = null;
                    this.tradeWs.onerror = null;
                    
                    if (this.tradeWs.readyState === WebSocket.OPEN || 
                        this.tradeWs.readyState === WebSocket.CONNECTING) {
                        this.tradeWs.close();
                    }
                    this.tradeWs = null;
                }
                
                // ê°•ì œì²­ì‚° WebSocket ì •ë¦¬
                if (this.liquidationWs) {
                    this.liquidationWs.onopen = null;
                    this.liquidationWs.onmessage = null;
                    this.liquidationWs.onclose = null;
                    this.liquidationWs.onerror = null;
                    
                    if (this.liquidationWs.readyState === WebSocket.OPEN || 
                        this.liquidationWs.readyState === WebSocket.CONNECTING) {
                        this.liquidationWs.close();
                    }
                    this.liquidationWs = null;
                }
            }

            clearCharts() {
                if (this.candlestickSeries) {
                    this.candlestickSeries.setData([]);
                }
                if (this.takerVolumeSeries) {
                    this.takerVolumeSeries.setData([]);
                }
                if (this.makerVolumeSeries) {
                    this.makerVolumeSeries.setData([]);
                }
                if (this.ratioSeries) {
                    this.ratioSeries.setData([]);
                }
                if (this.longLiquidationSeries) {
                    this.longLiquidationSeries.setData([]);
                }
                if (this.shortLiquidationSeries) {
                    this.shortLiquidationSeries.setData([]);
                }
            }

            resetMinuteData() {
                this.currentMinuteData = {
                    timestamp: null,
                    takerBuyQuoteVolume: 0,
                    totalQuoteVolume: 0
                };
                
                this.currentRatioCandle = {
                    timestamp: null,
                    open: null,
                    high: null,
                    low: null,
                    close: null
                };
                
                this.currentVolumeData = {
                    timestamp: null,
                    takerVolume: 0,
                    makerVolume: 0
                };
                
                this.currentLiquidationData = {
                    timestamp: null,
                    longLiquidation: 0,
                    shortLiquidation: 0
                };
                
                console.log('ê±°ë˜ëŸ‰ ë° ê°•ì œì²­ì‚° ë°ì´í„° ì™„ì „ ì´ˆê¸°í™”');
            }

            updateStatus(text, connected) {
                document.getElementById('statusText').textContent = text;
                const statusDot = document.getElementById('statusDot');
                if (connected) {
                    statusDot.classList.add('connected');
                } else {
                    statusDot.classList.remove('connected');
                }
            }
        }

        // ì•± ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', () => {
            new BinanceFuturesDashboard();
        });
    </script>
</body>
</html>