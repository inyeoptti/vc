<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Binance USDT-M 1m Z-Score Bar Chart Race</title>
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
	<style>
		:root { --bg:#0b1020; --fg:#e6eaff; --muted:#aab0c5; --grid:#1a2036; }
		html,body{ height:100%; margin:0; font-family:'Inter',system-ui,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--fg); }
		.container{ max-width:1100px; margin:0 auto; padding:24px; }
		h1{ margin:0 0 8px; font-weight:800; font-size:24px; }
		p.caption{ margin:0 0 20px; color:var(--muted); font-size:13px; }
		.chart-wrap{ background:#0f1530; border:1px solid #141a33; border-radius:12px; padding:16px; box-shadow:0 8px 24px rgba(0,0,0,0.3); }
		#chart{ width:100%; height:640px; }
		.footer{ margin-top:16px; font-size:12px; color:var(--muted); display:flex; justify-content:space-between; gap:12px; flex-wrap:wrap; }
		.badge{ display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; background:#10183a; border:1px solid #17224a; color:#b7c0e6; font-size:12px; }
		.prevlist{ display:flex; gap:6px; flex-wrap:wrap; align-items:center; }
	</style>
	<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1DQYSZQPZ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1DQYSZQPZ0');
</script>
</head>
<body>
	<div class="container">
		<h1>Binance USDT-M 1분 Z-Score Bar Chart Race</h1>
		<p class="caption">USDT 선물 · 롤링 100개 1분봉 기준 · 현재 진행 중 봉의 거래량 Z-스코어 상위 20</p>
		<div class="chart-wrap">
			<div id="chart"></div>
		</div>
		<div class="footer">
			<span class="badge">데이터: Binance klines(1m) + websocket</span>
			<span class="badge" id="status">초기화 중...</span>
			<span class="badge" id="countdown">남은 시간: --초</span>
		</div>
		<div class="footer" id="prevFooter" style="display:none;">
			<span class="badge">직전 1분 Top5</span>
			<div class="prevlist" id="prevList"></div>
		</div>
	</div>

	<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
	<script>
	(function(){
		// --- Color utilities ---
		function hashStringToInt(input){ let hash=0; for(let i=0;i<input.length;i++){ hash=((hash<<5)-hash+input.charCodeAt(i))|0; } return Math.abs(hash); }
		function hslToRgb(h,s,l){ h/=360; s/=100; l/=100; const c=(1-Math.abs(2*l-1))*s; const x=c*(1-Math.abs(((h*6)%2)-1)); const m=l-c/2; let r1=0,g1=0,b1=0; const seg=Math.floor(h*6); switch(seg){case 0:r1=c;g1=x;b1=0;break;case 1:r1=x;g1=c;b1=0;break;case 2:r1=0;g1=c;b1=x;break;case 3:r1=0;g1=x;b1=c;break;case 4:r1=x;g1=0;b1=c;break;case 5:r1=c;g1=0;b1=x;break;} return { r:Math.round((r1+m)*255), g:Math.round((g1+m)*255), b:Math.round((b1+m)*255) }; }
		function rgbToHex(r,g,b){ return '#' + [r,g,b].map(v=>v.toString(16).padStart(2,'0')).join(''); }
		function getSymbolColor(symbol){ const base=hashStringToInt(symbol); const hue=base%360; const rgb=hslToRgb(hue,65,52); return { hex:rgbToHex(rgb.r,rgb.g,rgb.b), rgb }; }
		function contrastTextColor(rgb){ const yiq=(rgb.r*299+rgb.g*587+rgb.b*114)/1000; return yiq>=140?'#000':'#fff'; }
		function formatUSDT(v){ if(!isFinite(v)) return '-'; const abs=Math.abs(v); if(abs>=1e9) return (v/1e9).toFixed(2)+'B'; if(abs>=1e6) return (v/1e6).toFixed(2)+'M'; if(abs>=1e3) return (v/1e3).toFixed(2)+'K'; return v.toFixed(0); }

		// --- DOM & Scales ---
		const container = d3.select('#chart');
		const statusEl = document.getElementById('status');
		const countdownEl = document.getElementById('countdown');
		const prevFooterEl = document.getElementById('prevFooter');
		const prevListEl = document.getElementById('prevList');
		const margin = { top: 32, right: 260, bottom: 40, left: 160 };
		function getSize(){ const rect=container.node().getBoundingClientRect(); return { width:Math.max(640,rect.width), height:Math.max(480,rect.height) }; }
		let { width, height } = getSize();
		const svg = container.append('svg').attr('width', width).attr('height', height);
		const plotW = () => width - margin.left - margin.right;
		const plotH = () => height - margin.top - margin.bottom;
		const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);
		const x = d3.scaleLinear().range([0, plotW()]);
		const y = d3.scaleBand().range([0, plotH()]).paddingInner(0.15).paddingOuter(0.1).align(0.5);
		const xAxis = d3.axisTop(x).ticks(5).tickSizeOuter(0);
		const gx = g.append('g').attr('class','x-axis');
		const gy = g.append('g').attr('class','y-axis');
		g.append('g').attr('class','grid').call(d3.axisTop(x).ticks(5).tickSize(-plotH()).tickFormat('')).selectAll('line').attr('stroke','#1a2036');

		let data=[]; let prevRank=new Map();
		function updateScales(){ const max=d3.max(data,d=>d.z)||1; x.domain([0, Math.max(1, max*1.1)]).nice(); y.domain(data.map(d=>d.symbol)); }
		function rankMap(arr){ const m=new Map(); arr.forEach((d,i)=>m.set(d.symbol,i)); return m; }
		function render(){
			updateScales();
			svg.interrupt();
			g.selectAll('.row').interrupt();
			gx.interrupt(); gy.interrupt(); g.select('.grid').interrupt();
			const t = svg.transition().duration(Math.max(60, Math.min(600, TICK_MS*0.9))).ease(d3.easeLinear);
			gx.transition(t).call(xAxis);
			const bottomY = () => Math.max(0, plotH() - y.bandwidth());
			const startY = (sym) => prevRank.has(sym) ? prevRank.get(sym) * y.step() : bottomY();
			const rows = g.selectAll('.row').data(data,d=>d.symbol).join(
				enter => enter.append('g').attr('class','row').attr('transform', d=>`translate(0,${startY(d.symbol)})`)
					.call(r=>{ r.append('rect').attr('rx',6).attr('height',y.bandwidth()).attr('width',1).attr('fill',d=>getSymbolColor(d.symbol).hex).attr('opacity',0.88);
						r.append('text').attr('class','label').attr('x',-10).attr('y',y.bandwidth()/2).attr('dominant-baseline','middle').attr('text-anchor','end').attr('fill','#e6eaff').style('cursor','pointer').on('click',(ev,d)=>{ const url='https://www.binance.com/en/futures/'+d.symbol; window.open(url,'_blank'); }).text(d=>d.symbol);
						r.append('text').attr('class','value').attr('x', plotW()+8).attr('y',y.bandwidth()/2).attr('dominant-baseline','middle').attr('fill','#b7c0e6').attr('text-anchor','start').text(''); })
					.call(r=>r.transition(t).attr('transform', d=>`translate(0,${y(d.symbol)})`).select('rect').attr('width', d=>x(d.z))),
				update => update.call(r=>r.transition(t).attr('transform', d=>`translate(0,${y(d.symbol)})`)),
				exit => exit.call(r=>r.transition(t).attr('transform', `translate(0,${bottomY()})`).style('opacity',0).remove())
			).order();
			rows.select('rect').transition(t).attr('height',y.bandwidth()).attr('width',d=>x(d.z)).attr('fill',d=>getSymbolColor(d.symbol).hex);
			rows.select('text.value')
				.each(function(d){
					const el=d3.select(this);
					el.selectAll('tspan').remove();
					const base = `z ${d.z.toFixed(2)} · ${formatUSDT(d.quote)} USDT · `;
					const pct = `${d.chg>=0?'+':''}${d.chg.toFixed(2)}%`;
					const low = d.quote < 100000;
					const pctColor = low ? '#666' : (d.chg>0 ? '#2ecc71' : d.chg<0 ? '#ff5a5a' : '#b7c0e6');
					el.append('tspan').text(base).attr('fill', low ? '#666' : '#b7c0e6');
					el.append('tspan').text(pct).attr('fill', pctColor).attr('font-weight', 600);
					this.setAttribute('y', y.bandwidth()/2);
					this.setAttribute('text-anchor','start');
					this.setAttribute('x', (typeof plotW === 'function') ? (plotW()+8) : (width - 160 - 260 + 8));
				});
			rows.select('text.label').style('cursor','pointer').on('click',(ev,d)=>{ const url='https://www.binance.com/en/futures/'+d.symbol; window.open(url,'_blank'); }).transition(t).attr('y', y.bandwidth()/2).attr('x', d=>{ const w=x(d.z); return w>80?Math.max(10,w-10):-10; }).attr('text-anchor','end').attr('fill', d=>{ const w=x(d.z); if (w>80){ const {rgb}=getSymbolColor(d.symbol); return contrastTextColor(rgb);} return '#e6eaff'; });
			gy.transition(t).call(d3.axisLeft(y).tickSize(0).tickFormat(''));
			prevRank = rankMap(data);
		}

		// --- Data layer ---
		const BINANCE_FAPI='https://fapi.binance.com';
		const BINANCE_WS_BASE='wss://fstream.binance.com/stream?streams=';
		const MAX_STREAMS_PER_CONN=1024; const WINDOW_LEN=100; const TICK_MS=120;
		const baselineMap=new Map(); // symbol -> number[] (last 100 closed 1m quote volumes)
		const currentQuoteVolume=new Map(); // symbol -> current 1m (in-progress) quote volume
		const currentOpenClose=new Map(); // symbol -> { o, c } for current 1m
		let nextCloseTime=0; // ms
		let lastSnapshotTime=0; // last kline close time we snapped
		let prevTimer=null; // hide timer for prevFooter

		function now(){ return Date.now(); }
		function meanStd(arr){ if(!arr||arr.length===0) return {mean:0,std:0}; let sum=0; for(const v of arr) sum+=v; const mean=sum/arr.length; let ss=0; for(const v of arr){ const d=v-mean; ss+=d*d; } const std=Math.sqrt(ss/arr.length); return {mean,std}; }
		function computeTop(){
			const out=[];
			for(const [sym,base] of baselineMap.entries()){
				if(!base || base.length<WINDOW_LEN) continue;
				const curr = currentQuoteVolume.get(sym) || 0;
				const oc = currentOpenClose.get(sym);
				let chg = 0;
				if(oc && isFinite(oc.o) && isFinite(oc.c) && oc.o>0){ chg = ((oc.c - oc.o) / oc.o) * 100; }
				const {mean,std} = meanStd(base);
				const z = std>0 ? (curr-mean)/std : 0;
				out.push({ symbol:sym, z: Math.max(0, z), quote: curr, chg });
			}
			out.sort((a,b)=>b.z-a.z);
			return out.slice(0,20);
		}
		function chunk(arr,n){ const out=[]; for(let i=0;i<arr.length;i+=n) out.push(arr.slice(i,i+n)); return out; }
		async function fetchUSDTPerpSymbols(){ const res=await fetch(`${BINANCE_FAPI}/fapi/v1/exchangeInfo`); const j=await res.json(); return j.symbols.filter(s=>s.contractType==='PERPETUAL' && s.quoteAsset==='USDT' && s.status==='TRADING').map(s=>s.symbol); }
		async function preloadBaselines(symbols){
			statusEl.textContent = `기초 데이터 로딩 중 (0/${symbols.length})`;
			let done=0;
			for(const group of chunk(symbols, 12)){
				await Promise.all(group.map(async (sym)=>{
					try{
						const url=`${BINANCE_FAPI}/fapi/v1/klines?symbol=${sym}&interval=1m&limit=${WINDOW_LEN}`;
						const res=await fetch(url);
						const arr=await res.json();
						const vols = Array.isArray(arr) ? arr.map(k=>parseFloat(k[7]/* quote volume 'q' */)).filter(v=>isFinite(v)) : [];
						baselineMap.set(sym, vols.slice(-WINDOW_LEN));
					} catch(e){ baselineMap.set(sym, []); }
					finally { done++; }
				}));
				statusEl.textContent = `기초 데이터 로딩 중 (${done}/${symbols.length})`;
			}
			statusEl.textContent = `기초 데이터 준비 완료 (${symbols.length} 심볼)`;
		}
		function openMultiStream(symbols){
			const url=BINANCE_WS_BASE + symbols.map(s=>`${s.toLowerCase()}@kline_1m`).join('/');
			const ws=new WebSocket(url);
			ws.onopen=()=>{ statusEl.textContent=`연결됨: ${symbols.length}개 스트림`; };
			ws.onmessage=(ev)=>{
				try{
					const msg=JSON.parse(ev.data);
					const d=msg.data; if(!d||d.e!=='kline') return;
					const k=d.k; const sym=k.s; const q=parseFloat(k.q)||0; const T=k.T||0; const isClosed=!!k.x; const o=parseFloat(k.o)||NaN; const c=parseFloat(k.c)||NaN;
					currentQuoteVolume.set(sym, q);
					if(isFinite(o) || isFinite(c)) currentOpenClose.set(sym, { o, c });
					if(T>0) nextCloseTime=T;
					if(isClosed){
						if (T>lastSnapshotTime){
							const snapshot = computeTop();
							showPrevTop(snapshot);
							lastSnapshotTime = T;
						}
						const base = baselineMap.get(sym) || [];
						base.push(q);
						while(base.length>WINDOW_LEN) base.shift();
						baselineMap.set(sym, base);
					}
				}catch(e){}
			};
			ws.onclose=()=>{ statusEl.textContent='연결 종료, 재연결 중...'; setTimeout(()=>openMultiStream(symbols),1500); };
			ws.onerror=()=>{ statusEl.textContent='오류'; };
		}

		function tick(){ data = computeTop(); render(); }
		function showPrevTop(list){
			if(!Array.isArray(list)) return;
			prevListEl.innerHTML = '';
			list.slice(0,5).forEach((d,idx)=>{
				const span=document.createElement('span');
				span.className='badge';
				const low = d.quote < 100000;
				const pct = `${d.chg>=0?'+':''}${d.chg.toFixed(2)}%`;
				const pctColor = low ? '#666' : (d.chg>0 ? '#2ecc71' : d.chg<0 ? '#ff5a5a' : '#b7c0e6');
				span.style.color = low ? '#666' : '#b7c0e6';
				span.innerHTML = `${idx+1}. ${d.symbol} · z ${d.z.toFixed(2)} · ${formatUSDT(d.quote)} USDT · <span style="color:${pctColor}; font-weight:600;">${pct}</span>`;
				prevListEl.appendChild(span);
			});
			prevFooterEl.style.display = 'flex';
			if(prevTimer){ clearTimeout(prevTimer); prevTimer=null; }
		}
		function updateCountdown(){
			let remainSec;
			if(nextCloseTime>0){ remainSec = Math.max(0, Math.ceil((nextCloseTime - now())/1000)); }
			else {
				const t=now(); const next=Math.ceil(t/60_000)*60_000; remainSec=Math.max(0, Math.ceil((next - t)/1000));
			}
			countdownEl.textContent = `남은 시간: ${remainSec}초`;
		}
		async function boot(){
			statusEl.textContent='심볼 목록 가져오는 중...';
			const symbols=await fetchUSDTPerpSymbols();
			statusEl.textContent=`심볼 ${symbols.length}개`;
			await preloadBaselines(symbols);
			for(const group of chunk(symbols, Math.min(MAX_STREAMS_PER_CONN,1024))){ openMultiStream(group); }
			setInterval(tick, TICK_MS);
			setInterval(updateCountdown, 200);
		}
		window.addEventListener('resize', ()=>{ clearTimeout(window.__rt); window.__rt=setTimeout(()=>{ const s=getSize(); width=s.width; height=s.height; svg.attr('width',width).attr('height',height); x.range([0,plotW()]); y.range([0,plotH()]); g.select('.grid').call(d3.axisTop(x).ticks(5).tickSize(-plotH()).tickFormat('')).selectAll('line').attr('stroke','#1a2036'); render(); },150); });
		boot();
		render();
	})();
	</script>
</body>
</html>



